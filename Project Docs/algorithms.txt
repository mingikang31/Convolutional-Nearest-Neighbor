\begin{algorithm}[tb]
\caption{Convolutional Nearest Neighbors (ConvNN)}
\label{alg:convnn}
\textbf{Input}: Feature map $\mathbf{X} \in \mathbb{R}^{B \times C \times H \times W}$\\
\textbf{Parameters}: Number of neighbors $K$, convolution weights $\mathbf{W}_{conv}$, magnitude type $\in \{\text{distance}, \text{similarity}\}$\\
\textbf{Output}: Transformed feature map $\mathbf{Y} \in \mathbb{R}^{B \times C' \times H \times W}$
\begin{algorithmic}[1]
\STATE \textbf{// Preprocessing}
\STATE $\mathbf{X}_{flat} \leftarrow \text{Flatten}(\mathbf{X})$ \COMMENT{Shape: $(B, C, H \times W)$}
\STATE $N \leftarrow H \times W$ \COMMENT{Number of spatial positions}
\STATE
\STATE \textbf{// Compute pairwise magnitude matrix}
\IF{magnitude type = \textit{distance}}
    \STATE $\mathbf{M} \leftarrow \text{EuclideanDistance}(\mathbf{X}_{flat}, \mathbf{X}_{flat})$ \COMMENT{Shape: $(B, N, N)$}
\ELSE
    \STATE $\mathbf{X}_{norm} \leftarrow \text{L2Normalize}(\mathbf{X}_{flat}, \text{dim}=1)$
    \STATE $\mathbf{M} \leftarrow \mathbf{X}_{norm}^T \cdot \mathbf{X}_{norm}$ \COMMENT{Cosine similarity}
\ENDIF
\STATE
\STATE \textbf{// Find K-nearest neighbors for each position}
\FOR{$b = 1$ to $B$}
    \FOR{$i = 1$ to $N$}
        \IF{magnitude type = \textit{distance}}
            \STATE $\mathcal{N}_i \leftarrow \text{ArgTopK}(\mathbf{M}[b, i, :], K, \text{largest}=\text{False})$
        \ELSE
            \STATE $\mathcal{N}_i \leftarrow \text{ArgTopK}(\mathbf{M}[b, i, :], K, \text{largest}=\text{True})$
        \ENDIF
        \STATE \textbf{// Gather neighbor features}
        \STATE $\mathbf{V}_{prime}[b, :, i \cdot K : (i+1) \cdot K] \leftarrow \mathbf{X}_{flat}[b, :, \mathcal{N}_i]$
    \ENDFOR
\ENDFOR
\STATE
\STATE \textbf{// Apply 1D convolution}
\STATE $\mathbf{Y}_{flat} \leftarrow \text{Conv1D}(\mathbf{V}_{prime}, \mathbf{W}_{conv}, \text{kernel}=K, \text{stride}=K)$
\STATE
\STATE \textbf{// Reshape to original spatial dimensions}
\STATE $\mathbf{Y} \leftarrow \text{Reshape}(\mathbf{Y}_{flat}, (B, C', H, W))$
\STATE
\STATE \textbf{return} $\mathbf{Y}$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[tb]
\caption{Convolutional Nearest Neighbors with Sampling}
\label{alg:convnn_sampling}
\textbf{Input}: Feature map $\mathbf{X} \in \mathbb{R}^{B \times C \times H \times W}$\\
\textbf{Parameters}: $K$ (neighbors), sampling $\in \{\text{all}, \text{random}, \text{spatial}\}$, $S$ (num samples)\\
\textbf{Output}: Transformed feature map $\mathbf{Y} \in \mathbb{R}^{B \times C' \times H \times W}$
\begin{algorithmic}[1]
\STATE $\mathbf{X}_{flat} \leftarrow \text{Flatten}(\mathbf{X})$ \COMMENT{Shape: $(B, C, H \times W)$}
\STATE $N \leftarrow H \times W$
\STATE
\IF{sampling = \textit{all}}
    \STATE $\mathbf{Q} \leftarrow \mathbf{X}_{flat}$ \COMMENT{Query from all positions}
\ELSIF{sampling = \textit{random}}
    \STATE $\mathcal{I}_{sample} \leftarrow \text{RandomSample}(N, S)$
    \STATE $\mathbf{Q} \leftarrow \mathbf{X}_{flat}[:, :, \mathcal{I}_{sample}]$ \COMMENT{Random subset}
\ELSIF{sampling = \textit{spatial}}
    \STATE $\mathcal{I}_{sample} \leftarrow \text{UniformGrid}(H, W, \sqrt{S})$
    \STATE $\mathbf{Q} \leftarrow \mathbf{X}_{flat}[:, :, \mathcal{I}_{sample}]$ \COMMENT{Spatial grid}
\ENDIF
\STATE
\STATE \textbf{// Compute magnitude between keys and queries}
\STATE $\mathbf{K} \leftarrow \mathbf{X}_{flat}$ \COMMENT{Keys from all positions}
\STATE $\mathbf{M} \leftarrow \text{ComputeMagnitude}(\mathbf{K}, \mathbf{Q})$
\STATE
\IF{sampling $\neq$ \textit{all}}
    \STATE $\mathbf{M}[\mathcal{I}_{sample}, \text{range}(S)] \leftarrow \infty$ \COMMENT{Exclude self-connections}
\ENDIF
\STATE
\STATE \textbf{// Gather K-nearest neighbors}
\STATE $\mathbf{V}_{prime} \leftarrow \text{GatherTopK}(\mathbf{X}_{flat}, \mathbf{M}, K)$
\STATE
\STATE \textbf{// Apply convolution and reshape}
\STATE $\mathbf{Y}_{flat} \leftarrow \text{Conv1D}(\mathbf{V}_{prime}, \text{kernel}=K, \text{stride}=K)$
\STATE $\mathbf{Y} \leftarrow \text{Reshape}(\mathbf{Y}_{flat}, (B, C', H, W))$
\STATE
\STATE \textbf{return} $\mathbf{Y}$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[tb]
\caption{1D Convolutional Nearest Neighbors (Conv1d-NN)}
\label{alg:conv1d_nn}
\textbf{Input}: Feature sequence $\mathbf{X} \in \mathbb{R}^{B \times C \times L}$\\
\textbf{Parameters}: Number of neighbors $K$, convolution weights $\mathbf{W}_{conv}$, magnitude type $\in \{\text{distance}, \text{similarity}\}$\\
\textbf{Output}: Transformed sequence $\mathbf{Y} \in \mathbb{R}^{B \times C' \times L}$
\begin{algorithmic}[1]
\STATE \textbf{// Compute pairwise magnitude matrix}
\IF{magnitude type = \textit{distance}}
    \STATE $\mathbf{M} \leftarrow \|\mathbf{x}_i\|^2 + \|\mathbf{x}_j\|^2 - 2\mathbf{x}_i^T\mathbf{x}_j$ for all $i,j \in [1, L]$
\ELSE
    \STATE $\hat{\mathbf{X}} \leftarrow \text{L2Normalize}(\mathbf{X}, \text{dim}=1)$
    \STATE $\mathbf{M} \leftarrow \hat{\mathbf{X}}^T \cdot \hat{\mathbf{X}}$ \COMMENT{Cosine similarity}
\ENDIF
\STATE
\STATE \textbf{// Find K-nearest neighbors for each position}
\STATE Initialize $\mathbf{V}_{prime} \in \mathbb{R}^{B \times C \times (L \cdot K)}$
\FOR{$b = 1$ to $B$}
    \FOR{$i = 1$ to $L$}
        \IF{magnitude type = \textit{distance}}
            \STATE $\mathcal{N}_i \leftarrow \text{ArgTopK}(\mathbf{M}[b, i, :], K, \text{largest}=\text{False})$
        \ELSE
            \STATE $\mathcal{N}_i \leftarrow \text{ArgTopK}(\mathbf{M}[b, i, :], K, \text{largest}=\text{True})$
        \ENDIF
        \STATE \textbf{// Gather features from K-nearest neighbors}
        \STATE $\mathbf{V}_{prime}[b, :, i \cdot K : (i+1) \cdot K] \leftarrow \mathbf{X}[b, :, \mathcal{N}_i]$
    \ENDFOR
\ENDFOR
\STATE
\STATE \textbf{// Apply 1D convolution with stride = K}
\STATE $\mathbf{Y} \leftarrow \text{Conv1D}(\mathbf{V}_{prime}, \mathbf{W}_{conv}, \text{kernel}=K, \text{stride}=K)$
\STATE
\STATE \textbf{return} $\mathbf{Y}$
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[tb]
\caption{1D Convolutional Nearest Neighbors with Sampling}
\label{alg:conv1d_nn_sampling}
\textbf{Input}: Feature sequence $\mathbf{X} \in \mathbb{R}^{B \times C \times L}$\\
\textbf{Parameters}: $K$ (neighbors), sampling $\in \{\text{all}, \text{random}, \text{spatial}\}$, $S$ (samples), magnitude type\\
\textbf{Output}: Transformed sequence $\mathbf{Y} \in \mathbb{R}^{B \times C' \times L}$
\begin{algorithmic}[1]
\STATE \textbf{// Select query positions based on sampling strategy}
\IF{sampling = \textit{all}}
    \STATE $\mathbf{Q} \leftarrow \mathbf{X}$ \COMMENT{Use all positions as queries}
    \STATE $\mathcal{I}_{query} \leftarrow [1, 2, ..., L]$
\ELSIF{sampling = \textit{random}}
    \STATE $\mathcal{I}_{query} \leftarrow \text{RandomPermutation}(L)[1:S]$
    \STATE $\mathbf{Q} \leftarrow \mathbf{X}[:, :, \mathcal{I}_{query}]$
\ELSIF{sampling = \textit{spatial}}
    \STATE $\mathcal{I}_{query} \leftarrow \text{Linspace}(1, L, S)$ \COMMENT{Uniformly spaced}
    \STATE $\mathbf{Q} \leftarrow \mathbf{X}[:, :, \mathcal{I}_{query}]$
\ENDIF
\STATE
\STATE \textbf{// Compute magnitude matrix between all positions and queries}
\STATE $\mathbf{K} \leftarrow \mathbf{X}$ \COMMENT{Keys are all positions}
\IF{magnitude type = \textit{distance}}
    \STATE $\mathbf{M} \leftarrow \text{EuclideanDistance}(\mathbf{K}, \mathbf{Q})$ \COMMENT{Shape: $(B, L, |\mathcal{I}_{query}|)$}
\ELSE
    \STATE $\mathbf{M} \leftarrow \text{CosineSimilarity}(\mathbf{K}, \mathbf{Q})$
\ENDIF
\STATE
\IF{sampling $\neq$ \textit{all}}
    \STATE \textbf{// Mask self-connections for sampled positions}
    \FOR{$i = 1$ to $|\mathcal{I}_{query}|$}
        \STATE $\mathbf{M}[:, \mathcal{I}_{query}[i], i] \leftarrow \begin{cases} \infty & \text{if distance} \\ -\infty & \text{if similarity} \end{cases}$
    \ENDFOR
\ENDIF
\STATE
\STATE \textbf{// Gather K-nearest neighbors and apply convolution}
\STATE $\mathbf{V}_{prime} \leftarrow \text{GatherTopK}(\mathbf{X}, \mathbf{M}, K)$
\STATE $\mathbf{Y} \leftarrow \text{Conv1D}(\mathbf{V}_{prime}, \text{kernel}=K, \text{stride}=K)$
\STATE
\STATE \textbf{return} $\mathbf{Y}$
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[tb]
\caption{1D Convolutional Nearest Neighbors (Conv1D-NN)}
\label{alg:conv1d_nn}
\textbf{Input}: Feature tensor $\mathbf{X} \in \mathbb{R}^{B \times C \times L}$ with shape $[B, C, L]$\\
\textbf{Parameters}: Number of neighbors $k$, convolution weights $W_{conv} \in \mathbb{R}^{C' \times C \times k}$\\
\textbf{Output}: Transformed tensor $\mathbf{Y} \in \mathbb{R}^{B \times C' \times L}$
\begin{algorithmic}[1]
\STATE \textbf{// Reshape to matrix form for each batch}
\FOR{$b = 1$ to $B$}
    \STATE $X^{(b)} \leftarrow \text{reshape}(\mathbf{X}[b, :, :]) \in \mathbb{R}^{L \times C}$ \COMMENT{Positions as rows}
    \STATE \textbf{// Normalize feature vectors}
    \FOR{$i = 1$ to $L$}
        \STATE $\mathbf{x}_i \leftarrow X^{(b)}[i, :] / \lVert X^{(b)}[i, :] \rVert_2$ \COMMENT{$\ell_2$-normalize}
    \ENDFOR
    \STATE
    \STATE \textbf{// Compute k-nearest neighbors indices}
    \STATE $S \leftarrow X^{(b)} \cdot (X^{(b)})^{\top} \in \mathbb{R}^{L \times L}$ \COMMENT{Similarity matrix}
    \STATE $I_k \leftarrow \argkmax_k(S) \in \{0,1\}^{L \times L}$ \COMMENT{k-hot encoded matrix}
    \STATE
    \STATE \textbf{// Gather features from k-nearest neighbors}
    \STATE Initialize $V_{prime}^{(b)} \in \mathbb{R}^{(L \cdot k) \times C}$
    \FOR{$i = 1$ to $L$}
        \STATE $\mathcal{N}_k(\mathbf{x}_i) \leftarrow X^{(b)}[I_k[i, :], :]$ \COMMENT{Select k neighbors}
        \STATE $V_{prime}^{(b)}[i \cdot k : (i+1) \cdot k, :] \leftarrow \mathcal{N}_k(\mathbf{x}_i)$
    \ENDFOR
    \STATE
    \STATE \textbf{// Reshape back to tensor form}
    \STATE $\mathbf{V}_{prime}^{(b)} \leftarrow \text{reshape}(V_{prime}^{(b)}) \in \mathbb{R}^{C \times (L \cdot k)}$
\ENDFOR
\STATE
\STATE \textbf{// Apply 1D convolution with stride = k}
\STATE $\mathbf{Y} \leftarrow \text{Conv1D}(\mathbf{V}_{prime}, W_{conv}, \text{kernel}=k, \text{stride}=k)$
\STATE
\STATE \textbf{return} $\mathbf{Y}$
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[tb]
\caption{Conv1D-NN Operation}
\label{alg:convnn}
\textbf{Input}: $\mathbf{X} \in \mathbb{R}^{B \times C \times L}$, where $B$ is batch size, $C$ channels, $L$ sequence length\\
\textbf{Parameters}: $k$ (neighbors), weights $W \in \mathbb{R}^{C' \times C \times k}$\\
\textbf{Output}: $\mathbf{Y} \in \mathbb{R}^{B \times C' \times L}$
\begin{algorithmic}[1]
\STATE \textbf{// For each batch element}
\FOR{$b \in [1, B]$}
    \STATE Let $X = \mathbf{X}[b, :, :]^{\top} \in \mathbb{R}^{L \times C}$ with columns $\mathcal{X} = \{\mathbf{x}_i\}_{i=1}^L$
    \STATE Normalize: $\hat{\mathbf{x}}_i \leftarrow \mathbf{x}_i / \lVert \mathbf{x}_i \rVert_2$ for all $i \in [1, L]$
    \STATE Let $\hat{X}$ be the matrix with columns $\{\hat{\mathbf{x}}_i\}_{i=1}^L$
    \STATE
    \STATE \textbf{// Compute k-nearest neighbors}
    \STATE $I_k \leftarrow \argkmax_k(\hat{X}\hat{X}^{\top}) \in \{0,1\}^{L \times L}$
    \STATE
    \STATE \textbf{// Aggregate neighbor features}
    \FOR{$i \in [1, L]$}
        \STATE $\mathcal{N}_k(\mathbf{x}_i) \leftarrow X[I_k[i, :], :]$ \COMMENT{Shape: $[k, C]$}
        \STATE $\mathbf{V}_{prime}[b, :, i \cdot k : (i+1) \cdot k] \leftarrow \mathcal{N}_k(\mathbf{x}_i)^{\top}$
    \ENDFOR
\ENDFOR
\STATE
\STATE \textbf{// Convolve aggregated features}
\STATE $\mathbf{Y} \leftarrow \sum_{j=0}^{k-1} W[:, :, j] \ast \mathbf{V}_{prime}[:, :, j::k]$ \COMMENT{Stride-k convolution}
\STATE
\STATE \textbf{return} $\mathbf{Y}$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[tb]
\caption{Conv1D-NN with Sampling}
\label{alg:convnn_sampling}
\textbf{Input}: $\mathbf{X} \in \mathbb{R}^{B \times C \times L}$, sampling $\in \{\text{all}, \text{random}, \text{spatial}\}$, $s$ samples\\
\textbf{Parameters}: $k$, $W \in \mathbb{R}^{C' \times C \times k}$\\
\textbf{Output}: $\mathbf{Y} \in \mathbb{R}^{B \times C' \times L}$
\begin{algorithmic}[1]
\FOR{$b \in [1, B]$}
    \STATE $X = \mathbf{X}[b, :, :]^{\top} \in \mathbb{R}^{L \times C}$
    \STATE
    \STATE \textbf{// Select query subset}
    \IF{sampling = \textit{random}}
        \STATE $\mathcal{Q} \leftarrow \text{RandomSample}(\{1, ..., L\}, s)$
    \ELSIF{sampling = \textit{spatial}}
        \STATE $\mathcal{Q} \leftarrow \{\lfloor 1 + i \cdot (L-1)/(s-1) \rfloor : i \in [0, s-1]\}$
    \ELSE
        \STATE $\mathcal{Q} \leftarrow \{1, ..., L\}$
    \ENDIF
    \STATE
    \STATE \textbf{// Compute similarities between all positions and queries}
    \STATE $Q \leftarrow X[\mathcal{Q}, :]$ \COMMENT{Query matrix}
    \STATE $S \leftarrow X \cdot Q^{\top} \in \mathbb{R}^{L \times |\mathcal{Q}|}$
    \IF{sampling $\neq$ \textit{all}}
        \STATE $S[\mathcal{Q}[i], i] \leftarrow -\infty$ for $i \in [1, |\mathcal{Q}|]$ \COMMENT{Mask self}
    \ENDIF
    \STATE
    \STATE \textbf{// Find k-nearest for each position}
    \STATE $I_k \leftarrow \argkmax_k(S) \in \{0,1\}^{L \times |\mathcal{Q}|}$
    \STATE Apply gathering and convolution as in Algorithm \ref{alg:convnn}
\ENDFOR
\STATE \textbf{return} $\mathbf{Y}$
\end{algorithmic}
\end{algorithm}